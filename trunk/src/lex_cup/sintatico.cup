package controle;

/*+--------------------------------------------------------------------+
  |   Projeto - COMPILADOR PASCAL PARA WEB.                            |
  |   Por: Luiz Eduardo da Silva                                       |
  |        Everton Josué da Silva                                      |
  +--------------------------------------------------------------------+*/

import java.util.*;
import entidade.*;

parser code  {:

    StringBuilder mepa, saida;
    Erro e;
    int contaVars;
    int deslocamento;
    int numeroEntradas;
    int rotulo;
    int nivel;
    int auxNumParam;
    int comando_escrita;
    int comando_leitura;
    
    /* Variáveis de controle - Chamada de Procedimento e Função */
    int chamada_rotina;           /* Valor 1 => uma chamada de rotina está sendo compilada */
    int indiceParametro;               /* Indica qual parâmetro está sendo compilado */
    ElemTabSimb elemRotina;          /* Instância do procedimento que está sendo compilado */

    /* Pilha de Controle de Tipos - PcT*/
    LinkedList<Tipo> pct = new LinkedList<Tipo>();
    int analisar_expr;                   /* Indica se é ou não avaliar a expressão*/ 

    Rotulo ultimoRotulo;
    LinkedList<ElemPilhaSem> pilhaSem = new LinkedList<ElemPilhaSem>();
    ArrayList<ElemTabSimb> tabSimbolo = new ArrayList<ElemTabSimb>();
    ElemTabSimb elemTab;
    ElemPilhaSem elemPilha;

    public sintatico(java.io.Reader input, StringBuilder mep, StringBuilder sai, Erro err) {
        super (new lexico (input));
        mepa = mep;
        saida = sai;
        e = err;
        nivel = -1;
    }

    public void report_semantic_error (String message) {
        report_error (message, cur_token);
        done_parsing();
    }

    public void report_error(String message, Object info) {
        Simbolo simb = (Simbolo)info;
        saida.append("ERRO na linha "+simb.getLine()+": "+message);
        e.setaErro (simb.getLine(), simb.getColumn ());
    }

    public void report_fatal_error (String message, Object info) {
        done_parsing();
    }

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Sintatico", current);
    }

    public void eliminaSimbolos(int nivel){

        int tamanhoTab = this.tabSimbolo.size() - 1;
        ElemTabSimb el;
        while(tamanhoTab != -1 && (el = this.tabSimbolo.get(tamanhoTab)).getNivel() == nivel){
            this.tabSimbolo.remove(tamanhoTab);
            tamanhoTab--;
        }
    }

    public void mostraTabSimb(){
        System.out.println("TabelaSimbolos - "+tabSimbolo.toString()+"\n");
    }

    public void mostraPilhaSem(){
        System.out.println("PilhaSemantica - "+pilhaSem.toString()+"\n");
    }

    public void mostraPcT(){
        System.out.println("Pilha de Controle de Tipos - "+pct.toString()+"\n");
    }

    public ElemTabSimb buscaSimbolo(String id){
        int tamanhoTab = this.tabSimbolo.size() - 1;
        ElemTabSimb e = null;

        while(tamanhoTab != -1 && !((e = tabSimbolo.get(tamanhoTab)).getNome().equals(id))){
            tamanhoTab--;
        }

        if(tamanhoTab == -1){
            return null;
        }
  
        return e;
    }

    public void cabecalhoFuncao(){
        
        int indice;
        ListIterator it;
        ArrayList<Variavel> parametros = null;
        Funcao funcao;
        ElemTabSimb elemFunc;

        /* Posicionar indice no início da marca DECLARACAO_ROTINA */
        indice = pilhaSem.indexOf(Marca.DECLARACAO_ROTINA);
        it = pilhaSem.listIterator(indice);
        it.next();
        it.remove();

        /* Desempilhar procedimento */
        elemFunc = (ElemTabSimb) it.next();

        /* Instaciar procedimento */
        funcao = new Funcao(rotulo, -numeroEntradas - 3);

        it.remove();
        
        if (numeroEntradas > 0) {
            parametros = criaParametros(it);
        }
        
        /* Add o ArrayList de parâmetros */
        funcao.setParametros(parametros);
        
        /* Adicionar procedimento na tabela de símbolos */
        elemFunc.setInfoC(funcao);

        funcao.setTipo((Tipo)pilhaSem.pollLast());

    }

    public void cabecalhoProcedimento(){

        int indice;
        ListIterator it;
        ArrayList<Variavel> parametros = null;
        Procedimento procedimento;
        ElemTabSimb elemProc;

        /* Posicionar indice no início da marca DECLARACAO_ROTINA */
        indice = pilhaSem.indexOf(Marca.DECLARACAO_ROTINA);
        it = pilhaSem.listIterator(indice);
        it.next();
        it.remove();

        /* Desempilhar procedimento */
        elemProc = (ElemTabSimb) it.next();

        /* Instaciar procedimento */
        procedimento = new Procedimento(rotulo);

        it.remove();
        
        if (numeroEntradas > 0) {
            parametros = criaParametros(it);
        }
        
        /* Add o ArrayList de parâmetros */
        procedimento.setParametros(parametros);
        
        /* Adicionar procedimento na tabela de símbolos */
        elemProc.setInfoC(procedimento);
    }

    /* Cria um ArrayList de parâmetros */
    public ArrayList<Variavel> criaParametros(ListIterator it){
        
        ArrayList<ElemTabSimb> listId;
        ArrayList<Variavel> parametros;
        Mecanismo mec;
        InfoComplementar infoC;
        int aux;
        IndiceArray indAr = null;
        Tipo tipo = null;

        aux = -numeroEntradas - 2;
        parametros = new ArrayList<Variavel>();

        for (int i = 0; i < numeroEntradas;) {

            indAr = null;
            tipo = null;    
            mec = (Mecanismo) it.next();
            it.remove();

            listId = new ArrayList<ElemTabSimb>();
            /* Desempilhar lista de identificadores */
            while ((elemPilha = (ElemPilhaSem) it.next()) instanceof ElemTabSimb) {
                elemTab = (ElemTabSimb) elemPilha;
                listId.add(elemTab);
                it.remove();
                i++;
            }

            if (elemPilha instanceof IndiceArray) {
                
                it.remove();
                indAr = (IndiceArray) elemPilha;
                tipo = (Tipo) it.next();
                it.remove();
            } else {
                
                it.remove();
                tipo = (Tipo) elemPilha;
            }

            /* Setar os atributos dos parâmetros */
            for (int j = 0; j < listId.size(); j++) {

                /* Verificar se é Array */
                if (indAr != null) {

                    /* Setar limites do Array*/
                    aux = aux - (indAr.getLimSuperior() - indAr.getLimInferior());
                    infoC = new Array(aux, tipo, indAr, mec);
                    aux += indAr.getLimSuperior() - indAr.getLimInferior();
                    parametros.add((Array) infoC);

                } else {
                    infoC = new Variavel(aux, tipo, mec);
                    parametros.add((Variavel) infoC);
                }

                aux++;
                /* Inserir parâmetro na tabela de símbolos*/
                listId.get(j).setInfoC(infoC);
                tabSimbolo.add(listId.get(j));

            }

        }
        
        return parametros;

    }

    public void analisaParametro(){
        
        Variavel param = null, arg;
        Funcao f;
        Procedimento p;
        boolean error = false;

        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        if(elemTab.getInfoC() instanceof Funcao){
            pct.add(((Funcao)elemTab.getInfoC()).getTipo());
        }else{    
            pct.add(((Variavel)elemTab.getInfoC()).getTipo());
        }

        System.out.println("Elemento: "+elemTab);
        mostraPcT();
        if (elemRotina.getInfoC() instanceof Funcao) {
            f = (Funcao) elemRotina.getInfoC();

            if (indiceParametro >= f.getNumParam()) {
                error = true;
            } else {
                param = f.getParametro(indiceParametro);
            }
        } else {
            p = (Procedimento) elemRotina.getInfoC();

            if (indiceParametro >= p.getNumParam()) {
                error = true;
            } else {
                param = p.getParametro(indiceParametro);
            }
        }

        arg = (Variavel) elemTab.getInfoC();

        /* Verificação de tipos na chamada de uma rotina */

        if (error) {
            report_semantic_error("Número de argumentos inválidos!");
        } else if (param.getTipo() == arg.getTipo() && arg.getClass() == param.getClass()) {
            if (param.getMecanismo() == Mecanismo.PAS_VAL) {
                
                if(elemTab.getInfoC() instanceof Array){
                    mepa.append("\tCRVA\t" + elemTab.getNivel() + "," + arg.getDeslocamento() + "," + ((Array)arg).getTamArray() +"\n");
                }else{
                    mepa.append("\tCRVL\t" + elemTab.getNivel() + "," + arg.getDeslocamento() + "\n");
                }
                
            } else {
                mepa.append("\tCREN\t" + elemTab.getNivel() + "," + arg.getDeslocamento() + "\n");
            }
        } else {
            report_semantic_error("Tipos incompatíveis!");
        }
    }

    public void verificaLimiteArray (String limI, String limS){
        
        int limInf, limSup;
        limInf = Integer.parseInt(limI.toString());
        limSup = Integer.parseInt(limS.toString());
        
        if(limInf > limSup){
            report_semantic_error ("O limite inferior deve ser menor ou igual ao limite superior!");
        }

        IndiceArray indA = new IndiceArray(limInf, limSup);
        pilhaSem.add(indA);
    }

    public void declaracaoVariaveis(){

        if(contaVars > 0){

            /* Posicionar indice no início da declaração de variáveis */
            int indice = pilhaSem.indexOf(Marca.DECLARACAO_VARS);
            int tamanhoPilha = pilhaSem.size();
            pilhaSem.remove(indice);
            
            ArrayList<ElemTabSimb> variaveis;
            Tipo tipo;
            IndiceArray indAr;

            for(int i = 0; i < contaVars ; ){

                variaveis = new ArrayList<ElemTabSimb>();
                tipo = null;
                indAr = null;

                /* Desempilha a lista de identificadores */
                while((elemPilha = pilhaSem.get(indice)) instanceof ElemTabSimb){
                    elemTab = (ElemTabSimb) elemPilha;
                    variaveis.add(elemTab);
                    i++;
                    pilhaSem.remove(indice);
                }

                elemPilha = pilhaSem.get(indice);
                pilhaSem.remove(indice);

                /* Tratar declação de array */    
                if(elemPilha instanceof IndiceArray){
                    indAr = (IndiceArray) elemPilha;
                    elemPilha = pilhaSem.get(indice);
                    pilhaSem.remove(indice);
                    tipo = (Tipo) elemPilha;                    
                    /* Ajustar deslocamento */
                }else{
                    tipo = (Tipo) elemPilha;
                }

                /* Setar os atributos das variáveis declaradas */
                if(indAr != null){
                    for(int j = 0; j < variaveis.size(); j++){
                        variaveis.get(j).setInfoC(new Array(deslocamento, tipo, indAr));
                        deslocamento += indAr.getLimSuperior() - indAr.getLimInferior() + 1;
                        if (tabSimbolo.contains(variaveis.get(j))) {
                            report_semantic_error("Identificador <" + elemTab.getNome() + "> já declarado!");
                        } else {
                            tabSimbolo.add(variaveis.get(j));
                        }
                    }                  
                }else{
                    for(int j = 0; j < variaveis.size(); j++){
                        variaveis.get(j).setInfoC(new Variavel(deslocamento++, tipo));
                        if (tabSimbolo.contains(variaveis.get(j))) {
                            report_semantic_error("Identificador <" + elemTab.getNome() + "> já declarado!");
                        } else {
                            tabSimbolo.add(variaveis.get(j));
                        }
                    }
                }
                
            }
            
            mepa.append ("\tAMEM\t"+(deslocamento)+"\n");
            elemPilha = new VariaveisDeclaradas(deslocamento);
            pilhaSem.add(elemPilha);
        }
    }

    public void chamadaProcedimento(){
            
        /* Posicionar indice no início da chamada procedimento */
        int indice = pilhaSem.indexOf(Marca.CHAMADA_PROCEDIMENTO);
        pilhaSem.remove(indice);
        elemTab = (ElemTabSimb) pilhaSem.remove(indice);
        Procedimento proc = (Procedimento) elemTab.getInfoC();
        if(proc.getNumParam() > indiceParametro){
            report_semantic_error("Número de argumentos inválidos!");
        }else{
            mepa.append ("\tCHPR\t"+"L"+proc.getRotulo()+"\n");
        }
    }

    public void armazena(){

        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        InfoComplementar infoC = elemTab.getInfoC();
        Variavel v;

        if( infoC instanceof Array){

            v = (Array)infoC;
            /* Verificar se é parâmetro */
            if(v.isParametro()){
                if(v.getMecanismo() == Mecanismo.PAS_END){

                    /* Verificar se está sendo compilado um comando de leitura */
                    if(comando_leitura == 1){
                        mepa.append ("\tALAI\t"+elemTab.getNivel()+","+ v.getDeslocamento()+","+(((Array)v).getTamArray() - 1)+"\n");
                    }else{
                        mepa.append ("\tARAI\t"+elemTab.getNivel()+","+ (v.getDeslocamento()+((Array)v).getTamArray() - 1)+"\n");
                    }

                }else{
                    mepa.append ("\tARLA\t"+elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
                }
            }else {
                if(comando_leitura == 1){
                    mepa.append ("\tARLA\t"+elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
                }else{
                    mepa.append ("\tARME\t"+elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
                }
            }
        }else if(infoC instanceof Variavel){

            v = (Variavel)infoC;
            if(v.isParametro()){
                if(v.getMecanismo() == Mecanismo.PAS_END){
                    mepa.append ("\tARMI\t"+ elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
                }else{
                    mepa.append ("\tARMZ\t"+elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
                }
            }else{    
                mepa.append ("\tARMZ\t"+elemTab.getNivel()+","+ v.getDeslocamento()+"\n");
            }
        }else if(infoC instanceof Funcao){
            mepa.append ("\tARMZ\t"+(elemTab.getNivel()+1)+","+((Funcao)infoC).getDeslocamento()+"\n");
        }
    }

    /* Seta variáveis de controle para declaração de variáveis */
    public void iniciaDecVars(){
        contaVars = 0; 
        deslocamento = 0;
        pilhaSem.add(Marca.DECLARACAO_VARS);
    }

    public void liberaMemoria(){
        if(pilhaSem.peekLast() instanceof VariaveisDeclaradas){
            elemPilha = pilhaSem.pollLast();
            mepa.append("\tDMEM\t"+((VariaveisDeclaradas)elemPilha).getQuantidade()+"\n");
        }
        eliminaSimbolos(nivel);
        nivel--;
    }

    public void instanciaIdentificador(String id){
        elemTab = new ElemTabSimb(id, nivel);
        if(tabSimbolo.contains(elemTab)){
            report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            elemTab.setInfoC(new Variavel(contaVars));
            tabSimbolo.add(elemTab);
        }
    }

    /* Seta variáveis para a declaração de Procedimentos e Funções */
    public void iniciaDecProcFunc(){
        rotulo++;
        mepa.append ("\tDSVS\tL"+rotulo+"\n");
        pilhaSem.add(new Rotulo(rotulo));
    }

    /* Finaliza declaração de Procedimentos e Funções */
    public void finalizaDecProcFunc(){
        elemPilha = pilhaSem.pollLast();
        if(elemPilha instanceof Rotulo){
          mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
        }
    }

    public void inicioChamadaFuncao(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Função <"+id+"> não declarada!");
        }else{
            pilhaSem.add(elemTab);
            elemRotina = elemTab;
            chamada_rotina = 1;
            mepa.append ("\tAMEM\t"+1+"\n");
        }
    }

    public void instanciaParametros(String id){
        elemTab = new ElemTabSimb(id, nivel);
        if(tabSimbolo.contains(elemTab)){
            report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            numeroEntradas++;
            pilhaSem.add(elemTab);
        }
    }
    
    public void inicioChamadaProc(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Procedimento <"+id+"> não declarado!");
        }else{
            pilhaSem.add(Marca.CHAMADA_PROCEDIMENTO);
            pilhaSem.add(elemTab);
            elemRotina = elemTab;
        }
    }

    public void empilhaIdentificador(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Identificador <"+id+"> não declarado!");
        }else{
            pilhaSem.add(elemTab);
        }
    }

    public void inicioIF(){
        rotulo++;
        mepa.append ("\tDSVF\tL"+rotulo+"\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void fimIF(){
        elemPilha = pilhaSem.pollLast();
        mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
    }

    public void inicioElse(){
        rotulo++;
        mepa.append ("\tDSVS\tL"+rotulo+"\n");
        elemPilha = pilhaSem.pollLast();
        mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void inicioComRepetitivo(){
        rotulo++;
        mepa.append ("L"+rotulo+":\tNADA\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void condicaoWhile(){
        rotulo++;
        mepa.append ("\tDSVF\tL"+rotulo+"\n");
        pilhaSem.add (new Rotulo(rotulo));
    }
    
    public void fimWhile(){
        ultimoRotulo = (Rotulo) pilhaSem.pollLast();
        elemPilha = pilhaSem.pollLast();
        mepa.append ("\tDSVS\tL"+((Rotulo)elemPilha).getRotulo()+"\n");
        mepa.append ("L"+ultimoRotulo.getRotulo()+":\tNADA\n");
    }

    public void condicaoRepeat(){
        ultimoRotulo = (Rotulo) pilhaSem.pollLast();
        mepa.append ("\tDSVF\tL"+ultimoRotulo.getRotulo()+"\n");
    }

    public void varAcesso(){
        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        InfoComplementar infoC = elemTab.getInfoC();
        Variavel v;

        if(analisar_expr == 1){
            pct.add(((Variavel)infoC).getTipo());
        }

        if (infoC instanceof Array) {
            
            v = (Array)infoC;
            /* Verificar se é parâmetro */
            mepa.append("\tCRCT\t" + ((Array)v).getLimInferior() + "\n");
            mepa.append("\tSUBT\n");
            if(v.isParametro()){
                if(v.getMecanismo() == Mecanismo.PAS_END){  
                    mepa.append("\tCREI\t"+elemTab.getNivel()+","+ v.getDeslocamento()+","+(((Array)v).getTamArray() - 1)+"\n");
                }else{
                    mepa.append("\tCREL\t" + elemTab.getNivel() + "," + v.getDeslocamento() + "\n");
                }
            }else{
                mepa.append("\tCREL\t" + elemTab.getNivel() + "," + v.getDeslocamento() + "\n");
            }
        } else {
            mepa.append("\tCRVL\t" + elemTab.getNivel() + "," + ((Variavel) infoC).getDeslocamento() + "\n");            
        }
    }

    public void iniciaTabSimb(){

        InfoComplementar inf;
        
        /*Adicionar tipos pré-definidos na tabela de símbolos*/

        elemTab = new ElemTabSimb("INTEGER",-1);
        inf = Tipo.INTEGER;
        elemTab.setInfoC(inf);
        tabSimbolo.add(elemTab);

        elemTab = new ElemTabSimb("BOOLEAN",-1);
        inf = Tipo.BOOLEAN;
        elemTab.setInfoC(inf);
        tabSimbolo.add(elemTab);

        /* Criar variáveis para os tipos false e true
        
        elemTab = new ElemTabSimb("false",0);
        inf = new Variavel(deslocamento++, Tipo.BOOLEAN);
        elemTab.setInfoC(inf);
        tabSimbolo.add(elemTab);

        elemTab = new ElemTabSimb("true",1);
        inf = new Variavel(deslocamento++, Tipo.BOOLEAN);
        elemTab.setInfoC(inf);
        tabSimbolo.add(elemTab);

        */

    }

    /* Verificar compatibilidade de tipos - Operador Relacional */
    public void analisaTipoOPR(){

        //System.out.println("Operador Relacional");
        //mostraPcT();
        Tipo tipo1, tipo2;
        tipo1 =  (Tipo)pct.pollLast();
        tipo2 =  (Tipo)pct.pollLast();
        if(tipo1 == Tipo.INTEGER && tipo2 == Tipo.INTEGER){
            pct.add(Tipo.BOOLEAN);
        }else if(tipo1 == Tipo.BOOLEAN && tipo2 == Tipo.BOOLEAN){
            pct.add(tipo1);
        }else{
            report_semantic_error ("Expressão inválida "+ tipo1 +" - " + tipo2);
        }
        //mostraPcT();
        //System.out.println();
        
    }

    /* Verificar compatibilidade de tipos - Operador Aritmético */
    public void analisaTipoOPA(){
        
        //System.out.println("Operador Aritmético");
        //mostraPcT();
        Tipo tipo1, tipo2;
        tipo1 =  (Tipo)pct.pollLast();
        tipo2 =  (Tipo)pct.pollLast();
        if(tipo1 == Tipo.INTEGER &&  tipo2 == Tipo.INTEGER){
            pct.add(tipo1);
        }else{
            report_semantic_error ("Expressão inválida "+ tipo1 +" - " + tipo2);
        }
        //mostraPcT();
        //System.out.println();
    }

    /* Verificar compatibilidade de tipos - Operador Lógico */
    public void analisaTipoOPL(){
        
        //System.out.println("Operador Lógico");
        //mostraPcT();
        Tipo tipo1, tipo2;
        tipo1 =  (Tipo)pct.pollLast();
        tipo2 =  (Tipo)pct.pollLast();
        if(tipo1 == Tipo.BOOLEAN &&  tipo2 == Tipo.BOOLEAN){
            pct.add(tipo1);
        }else{
            report_semantic_error ("Expressão inválida "+ tipo1 +" - " + tipo2);
        }
        //mostraPcT();
        //System.out.println();
    }

    /* Verificar compatibilidade de tipos na atribuição */
    public void verificaTiposAtrib(){
        
        //System.out.println("Atribuicao");
        //mostraPcT();
        Tipo tipo1, tipo2;
        tipo1 =  (Tipo)pct.pollLast();

        elemTab = (ElemTabSimb)pilhaSem.peekLast();
        if(elemTab.getInfoC() instanceof Funcao){
            tipo2 = ((Funcao)elemTab.getInfoC()).getTipo();
        }else{
            tipo2 = ((Variavel)elemTab.getInfoC()).getTipo();
        }

        if(tipo1 != tipo2){
            report_semantic_error ("Tipos incompatíveis "+ tipo2 +" - " + tipo1);
        }
        //mostraPcT();
        //System.out.println();    
    }

:};

terminal 
        S_DIFERENTE, S_DOISPTOS, S_FECHAPAR, S_PROCEDURE, S_FUNCTION,
        S_MAIGUAL, S_MEIGUAL, S_PROGRAM, S_PONTOVG, S_ABREPAR, S_VIRGULA,
        S_ATRIBUI, S_NUMERO, S_WHILE, S_WRITE, S_READ, S_MAIOR, S_MENOR,
        S_IGUAL, S_MENOS, S_VEZES, S_PONTO, S_BEGIN, S_THEN,
        S_ELSE, S_MAIS, S_VAR, S_END, S_DIV, S_AND, S_NOT,
        S_IF, S_DO, S_OR, S_REPEAT, S_UNTIL, S_IDENTIF, S_CONST, S_TYPE,
        S_ARRAY, S_ABRECOL, S_FECHACOL, S_OF, S_PTOPTO
;

non terminal 
        programa, bloco, variaveis, declaracao_de_constante, declaracoes_de_vars,
        lista_de_identificadores, corpo, sequencia_comandos, denotacao_de_tipo,
        comando_sem_rotulo, chamada_comando_escrita, lista_de_constante, novo_tipo,
        chamada_comando_leitura, lista_de_expressoes, declaracao_de_tipo, novo_tipo_estrutura,
        lista_de_variaveis, atribuicao, composto, definicao_de_constante, estrutura_tipo,
        lista_comandos_sem_rotulo, condicional, alternativa_cond, lista_de_tipo, tipo_array,
        repetitivo, expressao, expressao_simples, termo, fator, tipo_de_retorno, tipo,
        declaracao_de_funcoes_e_procendimentos, lista_de_declaracao_de_funcao_ou_procedimento,
        declaracao_de_funcao_ou_procedimento, declaracao_de_procedimento, declaracao_de_funcao,
        cabecalho_procedimento, cabecalho_funcao, lista_formal_de_parametros, secao_lista_de_parametros_formais,
        secao_de_parametros_formais, parametro_por_valor, parametro_por_referencia, lista_de_parametros,
        chamada_procedimento, chamada_funcao, parametros, lista_de_parametros_atuais, parametros_atuais,
        lista_de_indices, definicao_de_tipo, tipo_indice, variavel_de_acesso, variavel_indexada,
        indice_de_lista_de_expressao
;

start with programa;

/*+----------------------------------------------------------+
  |        Producoes Sintaticas da linguagem PASCAL          |
  +----------------------------------------------------------+*/

programa 
    ::=
    {: 
        parser.mepa.append ("\tINPP\n");
        parser.iniciaTabSimb();
    :}
    S_PROGRAM S_IDENTIF S_PONTOVG bloco S_PONTO
    {: 
        //parser.mostraPcT();
        parser.mepa.append ("\tPARA\n\tFIM\n"); 
    :}
;

bloco
    ::= 
    {: parser.nivel++; :}
    declaracao_de_constante
    declaracao_de_tipo
    variaveis
    declaracao_de_funcoes_e_procendimentos
    corpo
    {: parser.liberaMemoria(); :}
;

variaveis
    ::=  /* vazio */
    | S_VAR 
    {: 
        parser.iniciaDecVars();
    :}
    declaracoes_de_vars
    {:
        parser.declaracaoVariaveis();
    :}
;

declaracao_de_constante
    ::=  /* vazio */
    | S_CONST lista_de_constante
;

lista_de_constante
    ::= lista_de_constante definicao_de_constante
    | definicao_de_constante
;

definicao_de_constante
    ::= S_IDENTIF:id
    {:
        parser.instanciaIdentificador(id.toString());
    :}
     S_IGUAL expressao S_PONTOVG
;

declaracao_de_tipo
    ::= /* vazio */
    | S_TYPE lista_de_tipo
;

lista_de_tipo
    ::= lista_de_tipo definicao_de_tipo
    | definicao_de_tipo
;

definicao_de_tipo
    ::= S_IDENTIF S_IGUAL denotacao_de_tipo S_PONTOVG
;

denotacao_de_tipo
    ::= 
    S_IDENTIF: id
    {:
        parser.elemTab = parser.buscaSimbolo(id.toString().toUpperCase());
        if(parser.elemTab == null){
            parser.report_semantic_error ("Tipo <"+id+"> não definido!");
        }else{
            parser.pilhaSem.add((Tipo)parser.elemTab.getInfoC());
        }
    :}
    | novo_tipo
;

novo_tipo
    ::= novo_tipo_estrutura
;

novo_tipo_estrutura
    ::= estrutura_tipo
;

estrutura_tipo
    ::= tipo_array
;

tipo_array
    ::= S_ARRAY S_ABRECOL lista_de_indices S_FECHACOL S_OF tipo
;

tipo
    ::= denotacao_de_tipo
;

lista_de_indices
    ::= lista_de_indices S_VIRGULA tipo_indice
    | tipo_indice
;

tipo_indice
    ::= S_NUMERO: limInf S_PTOPTO S_NUMERO: limSup
    {:
        parser.verificaLimiteArray(limInf.toString(), limSup.toString());
    :}
;


declaracoes_de_vars
    ::= declaracoes_de_vars lista_de_identificadores S_DOISPTOS denotacao_de_tipo S_PONTOVG
    | lista_de_identificadores S_DOISPTOS denotacao_de_tipo S_PONTOVG
;

declaracao_de_funcoes_e_procendimentos
    ::=  /*vazio*/
    | {:
        parser.iniciaDecProcFunc();
      :}
    lista_de_declaracao_de_funcao_ou_procedimento S_PONTOVG
    {:
        parser.finalizaDecProcFunc();
    :}
;

lista_de_declaracao_de_funcao_ou_procedimento
    ::= lista_de_declaracao_de_funcao_ou_procedimento S_PONTOVG
    declaracao_de_funcao_ou_procedimento
    | declaracao_de_funcao_ou_procedimento
   
;

declaracao_de_funcao_ou_procedimento
    ::= {:
            parser.rotulo++;
            parser.auxNumParam = 0;
        :}
    declaracao_de_procedimento
    |   {:
            parser.rotulo++;
            parser.auxNumParam = 0;
        :}
    declaracao_de_funcao
;

declaracao_de_procedimento
    ::= 
    {: 
        parser.mepa.append ("L"+parser.rotulo+":\tENPR\t"+(parser.nivel+1)+"\n"); 
    :}
    cabecalho_procedimento
    {:
        parser.cabecalhoProcedimento();
    :}
    S_PONTOVG bloco
    {:
        parser.mepa.append ("\tRTPR\t"+(parser.nivel+1)+","+parser.numeroEntradas+"\n");
    :}
;

cabecalho_procedimento
    ::= S_PROCEDURE S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(Marca.DECLARACAO_ROTINA);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    | S_PROCEDURE S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(Marca.DECLARACAO_ROTINA);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    lista_formal_de_parametros

;

declaracao_de_funcao
    ::= 
    {: 
        parser.mepa.append ("L"+parser.rotulo+":\tENPR\t"+(parser.nivel+1)+"\n"); 
    :}
    cabecalho_funcao
    {:
        parser.cabecalhoFuncao();
    :}
    S_PONTOVG bloco
    {:
        parser.mepa.append ("\tRTPR\t"+(parser.nivel+1)+", "+parser.numeroEntradas+"\n");
    :}
;

cabecalho_funcao
    ::= S_FUNCTION S_IDENTIF:id 
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(Marca.DECLARACAO_ROTINA);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    S_DOISPTOS tipo_de_retorno

    | S_FUNCTION S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(Marca.DECLARACAO_ROTINA);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    lista_formal_de_parametros S_DOISPTOS tipo_de_retorno
;

tipo_de_retorno
    ::= S_IDENTIF:id
    {:
        //Buscar tipo na tabela de simbolos
        parser.pilhaSem.add(Tipo.INTEGER);
    :}
;

chamada_funcao
    ::= S_IDENTIF:id
    {:
        parser.inicioChamadaFuncao(id.toString());
    :}
    parametros 
;

lista_formal_de_parametros
    ::= S_ABREPAR 
    {:
        parser.nivel++;
        parser.numeroEntradas = 0;
    :}
    secao_lista_de_parametros_formais 
    {:
        parser.nivel--;
    :}
    S_FECHAPAR
;

secao_lista_de_parametros_formais
    ::= secao_lista_de_parametros_formais S_PONTOVG secao_de_parametros_formais
    | secao_de_parametros_formais
;

secao_de_parametros_formais
    ::= parametro_por_valor
    | parametro_por_referencia
;

parametro_por_valor
    ::= 
    {:
        parser.pilhaSem.add(Mecanismo.PAS_VAL);
    :}
    lista_de_parametros S_DOISPTOS denotacao_de_tipo
;

parametro_por_referencia
    ::= 
    {:
        parser.pilhaSem.add(Mecanismo.PAS_END);
    :}
    S_VAR lista_de_parametros S_DOISPTOS denotacao_de_tipo
;

lista_de_parametros
    ::= lista_de_parametros S_VIRGULA S_IDENTIF:id
    {:
        parser.instanciaParametros(id.toString());
    :}
    | S_IDENTIF:id
    {:
        parser.instanciaParametros(id.toString());
    :}
;

lista_de_identificadores
    ::= lista_de_identificadores S_VIRGULA S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);    
        parser.pilhaSem.add(parser.elemTab);
        parser.contaVars++;
    :}
    | S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        parser.pilhaSem.add(parser.elemTab);
        parser.contaVars++;
    :}
;

corpo
    ::= S_BEGIN sequencia_comandos S_END
;

sequencia_comandos
    ::= sequencia_comandos S_PONTOVG comando_sem_rotulo
    | comando_sem_rotulo
;
comando_sem_rotulo
    ::=  /* vazio */
    | chamada_comando_escrita
    |   {: parser.comando_leitura = 1; :}
        chamada_comando_leitura
        {: parser.comando_leitura = 0; :}
    | chamada_procedimento
        {:
            parser.chamadaProcedimento();
            parser.chamada_rotina = 0;
        :}
    | atribuicao
        {:
            parser.verificaTiposAtrib();
            parser.armazena();
            parser.analisar_expr = 0;
        :}
    | composto
    | condicional
        {:
            parser.analisar_expr = 0;
        :}
    | repetitivo
        {:
            parser.analisar_expr = 0;
        :}
;

chamada_procedimento
    ::= S_IDENTIF:id
    {:
        parser.chamada_rotina = 1;
        parser.indiceParametro = 0;
        parser.inicioChamadaProc(id.toString());
    :}
    parametros
    | S_IDENTIF:id
    {:
        parser.inicioChamadaProc(id.toString());
    :}
;

parametros
    ::= S_ABREPAR lista_de_parametros_atuais S_FECHAPAR
;

lista_de_parametros_atuais
    ::= lista_de_parametros_atuais S_VIRGULA parametros_atuais
    {:
        parser.indiceParametro++;
    :}
    | 
    parametros_atuais
    {:
        parser.indiceParametro++;
    :}
;

parametros_atuais
    ::= expressao
    | expressao S_DOISPTOS expressao
    | expressao S_DOISPTOS expressao S_DOISPTOS expressao
;

chamada_comando_escrita
    ::= S_WRITE
    {:
        parser.comando_escrita = 1;
        parser.analisar_expr = 1;
    :}
    S_ABREPAR lista_de_expressoes S_FECHAPAR
    {:
        parser.comando_escrita = 0;
        parser.analisar_expr = 0;
        parser.pct.pollLast();
    :}
;

chamada_comando_leitura
    ::= S_READ S_ABREPAR lista_de_variaveis S_FECHAPAR
;

lista_de_expressoes
    ::=  /* vazio */
    | lista_de_expressoes S_VIRGULA 
    expressao
    {:
        if(parser.comando_escrita == 1){
            parser.mepa.append ("\tIMPR\n");
        }
    :}
    | expressao
    {:
        if(parser.comando_escrita == 1){
            parser.mepa.append ("\tIMPR\n");
        }
    :}
;

lista_de_variaveis
    ::=  /* vazio */
    | lista_de_variaveis S_VIRGULA {: parser.mepa.append("\tLEIT\n"); :}
    variavel_de_acesso
    {:
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.peekLast();
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if( infoC instanceof Array){
            parser.mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            parser.mepa.append ("\tSUBT\n");
        }
        parser.armazena();
    :}
    | {: parser.mepa.append("\tLEIT\n"); :} variavel_de_acesso
    {:
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.peekLast();
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if( infoC instanceof Array){
            parser.mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            parser.mepa.append ("\tSUBT\n");
        }
        parser.armazena();
    :}

;

atribuicao
    ::= variavel_de_acesso
    {:
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if (infoC instanceof Array) {
            parser.mepa.append("\tCRCT\t" + ((Array) infoC).getLimInferior() + "\n");
            parser.mepa.append("\tSUBT\n");
        }
    :}
    S_ATRIBUI
    {:
        parser.analisar_expr = 1;
    :}
    expressao
;

variavel_de_acesso
    ::= 
    S_IDENTIF:id
    {:
        parser.empilhaIdentificador(id.toString());
    :}
    | variavel_indexada
;

variavel_indexada
    ::= variavel_de_acesso S_ABRECOL indice_de_lista_de_expressao S_FECHACOL
;

indice_de_lista_de_expressao
    ::= indice_de_lista_de_expressao S_VIRGULA expressao
    | expressao
;

composto
    ::= S_BEGIN lista_comandos_sem_rotulo S_END
;

lista_comandos_sem_rotulo
    ::= lista_comandos_sem_rotulo S_PONTOVG comando_sem_rotulo
    | comando_sem_rotulo
;

condicional
    ::= S_IF
    {:
        parser.analisar_expr = 1;
    :}
    expressao
    {:
        parser.pct.pollLast();
        parser.inicioIF();
    :}
    S_THEN
    comando_sem_rotulo
    alternativa_cond
    {:
        parser.fimIF();
    :}
;

alternativa_cond
    ::= /* vazio */
    | S_ELSE
    {:
        parser.inicioElse();
    :}
    comando_sem_rotulo
;

repetitivo
    ::= S_WHILE
        {:
            parser.inicioComRepetitivo();
            parser.analisar_expr = 1;
        :}
        expressao
        {:
            parser.condicaoWhile();
            parser.pct.pollLast();
        :}
        S_DO comando_sem_rotulo
        {:
            parser.fimWhile();
        :}

    | S_REPEAT
        {:
            parser.inicioComRepetitivo();
        :}
        sequencia_comandos
        S_UNTIL
        {:
            parser.analisar_expr = 1;
        :}
        expressao
        {:
            parser.condicaoRepeat();
            parser.pct.pollLast();
        :}
;

expressao
    ::= expressao_simples S_IGUAL expressao_simples
    {: 
            
        parser.mepa.append ("\tCMIG\n");
        parser.analisaTipoOPR();
    :}
    | expressao_simples S_DIFERENTE expressao_simples
    {:  
        parser.mepa.append ("\tCMDG\n"); 
        parser.analisaTipoOPR();
    :}
    | expressao_simples S_MENOR expressao_simples
    {: 
        parser.mepa.append ("\tCMME\n"); 
        parser.analisaTipoOPR();
    :}
    | expressao_simples S_MAIOR expressao_simples
    {: 
        parser.analisaTipoOPR();
        parser.mepa.append ("\tCMMA\n"); 
    :}
    | expressao_simples S_MEIGUAL expressao_simples
    {: 
        parser.mepa.append ("\tCMEG\n"); 
        parser.analisaTipoOPR();
    :}
    | expressao_simples S_MAIGUAL expressao_simples
    {: 
        parser.mepa.append ("\tCMAG\n"); 
        parser.analisaTipoOPR();
    :}
    | expressao_simples
;

expressao_simples
    ::= expressao_simples S_MAIS  termo
    {: 
        parser.analisaTipoOPA();
        parser.mepa.append ("\tSOMA\n"); 
    :}
    | expressao_simples S_MENOS termo
    {: 
        parser.mepa.append ("\tSUBT\n");
        parser.analisaTipoOPA();
    :}
    | expressao_simples S_OR termo
    {: 
        parser.mepa.append ("\tDISJ\n"); 
        parser.analisaTipoOPL();
    :}
    | S_MAIS termo
    | S_MENOS termo
    {: 
        parser.mepa.append ("\tINVR\n"); 
    :}
    | termo
;

termo
    ::= termo S_VEZES fator
    {: 
        parser.mepa.append ("\tMULT\n"); 
        parser.analisaTipoOPA();
    :}
    | termo S_DIV fator
    {: 
        parser.mepa.append ("\tDIVI\n"); 
        parser.analisaTipoOPA();
    :}
    | termo S_AND fator
    {: 
        parser.mepa.append ("\tCONJ\n"); 
        parser.analisaTipoOPL();
    :}
    | fator
;

fator
    ::=
    variavel_de_acesso
    {:
        if(parser.chamada_rotina == 1){
            parser.analisaParametro();
        }else{
            parser.varAcesso();
        }
    :}
    | S_NUMERO:numero
    {: 
        parser.mepa.append ("\tCRCT\t"+numero+"\n");
        if(parser.analisar_expr == 1){
            parser.pct.add(Tipo.INTEGER);
        }
    :}
    | chamada_funcao
    {:
        parser.chamada_rotina = 0;
        parser.indiceParametro = 0;
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.pollLast();
        Funcao func = (Funcao) parser.elemTab.getInfoC();
        parser.mepa.append ("\tCHPR\t"+"L"+func.getRotulo()+"\n");
        if(parser.analisar_expr == 1){
            parser.pct.add(func.getTipo());
        }
     :}
    | S_ABREPAR expressao S_FECHAPAR
    | S_NOT fator
    {: 
        parser.mepa.append ("\tNEGA\n"); 
    :}
;
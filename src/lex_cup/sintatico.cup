package controle;

/*+--------------------------------------------------------------------+
  |   Projeto - COMPILADOR PASCAL PARA WEB.                            |
  |   Por: Luiz Eduardo da Silva                                       |
  |        Everton Josué da Silva                                      |
  +--------------------------------------------------------------------+*/

import java.util.*;
import entidade.*;

parser code  {:

    StringBuilder mepa, saida;
    Erro e;
    int contaVars;
    int deslocamento;
    int numeroEntradas;
    int numeroArgumentos;
    int rotulo;
    int nivel;
    int auxNumParam;
    int pre_rotina;
    int comando_escrita;
    int comando_leitura;
    Rotulo ultimoRotulo;
    LinkedList<ElemPilhaSem> pilhaSem = new LinkedList<ElemPilhaSem>();
    ArrayList<ElemTabSimb> tabSimbolo = new ArrayList<ElemTabSimb>();
    ElemTabSimb elemTab;
    ElemPilhaSem elemPilha;

    public sintatico(java.io.Reader input, StringBuilder mep, StringBuilder sai, Erro err) {
        super (new lexico (input));
        mepa = mep;
        saida = sai;
        e = err;
        nivel = -1;
    }

    public void report_semantic_error (String message) {
        report_error (message, cur_token);
        done_parsing();
    }

    public void report_error(String message, Object info) {
        Simbolo simb = (Simbolo)info;
        saida.append("ERRO na linha "+simb.getLine()+": "+message);
        e.setaErro (simb.getLine(), simb.getColumn ());
    }

    public void report_fatal_error (String message, Object info) {
        done_parsing();
    }

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Sintatico", current);
    }

    public void eliminaSimbolos(int nivel){

        int tamanhoTab = this.tabSimbolo.size() - 1;
        ElemTabSimb el;
        while(tamanhoTab != -1 && (el = this.tabSimbolo.get(tamanhoTab)).getNivel() == nivel){
            this.tabSimbolo.remove(tamanhoTab);
            tamanhoTab--;
        }
    }

    public void mostraTabSimb(){
        System.out.println("TabelaSimbolos - "+tabSimbolo.toString()+"\n");
    }

    public void mostraPilhaSem(){
        System.out.println("PilhaSemantica - "+pilhaSem.toString()+"\n");
    }

    public ElemTabSimb buscaSimbolo(String id){
        int tamanhoTab = this.tabSimbolo.size() - 1;
        ElemTabSimb e = null;

        while(tamanhoTab != -1 && !((e = tabSimbolo.get(tamanhoTab)).getNome().equals(id))){
            tamanhoTab--;
        }

        if(tamanhoTab == -1){
            return null;
        }
  
        return e;
    }

    public void cabecalhoFuncao(){
        //Obter tipo da funcao
        Tipo tipo = (Tipo) pilhaSem.pollLast();

        //Obter parametros caso tenha
        Funcao func = new Funcao(rotulo, tipo, -3-numeroEntradas);
        if(numeroEntradas > 0){
            ListIterator it = pilhaSem.listIterator(pilhaSem.size() - numeroEntradas);
            while(it.hasNext()){
                func.addParametro((Parametro)it.next());
                it.remove();
            }
        }
        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        elemTab.setInfoC(func);
    }

    public void cabecalhoProcedimento(){

        //Obter parametros caso tenha
        Procedimento proc = new Procedimento(rotulo);
        if(numeroEntradas > 0){
            ListIterator it = pilhaSem.listIterator(pilhaSem.size() - numeroEntradas);
            while(it.hasNext()){
                proc.addParametro((Parametro)it.next());
                it.remove();
            }
        }
        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        elemTab.setInfoC(proc);
    }

    public void verificaLimiteArray (String limI, String limS){
        
        int limInf, limSup;
        limInf = Integer.parseInt(limI.toString());
        limSup = Integer.parseInt(limS.toString());
        
        if(limInf > limSup){
            report_semantic_error ("O limite inferior deve ser menor ou igual ao limite superior!");
        }

        IndiceArray indA = new IndiceArray(limInf, limSup);
        pilhaSem.add(indA);
    }

    public void declaracaoVariaveis(){
        
        if(contaVars > 0){

            /* Posicionar indice no início da declaração de variáveis */
            int indice = pilhaSem.indexOf(Marca.DECLARACAO_VARS);
            int tamanhoPilha = pilhaSem.size();
            pilhaSem.remove(indice);
            
            for(int i = 0; i < contaVars ; i++){
                
                elemPilha = pilhaSem.get(indice);
                elemTab = (ElemTabSimb) elemPilha;

                if(tabSimbolo.contains(elemTab)){
                    report_semantic_error ("Identificador <"+elemTab.getNome()+"> já declarado!");
                }

                /* Tratar declação de array */    
                if(indice+1 < pilhaSem.size() && pilhaSem.get(indice+1) instanceof IndiceArray){
                    pilhaSem.remove(indice);
                    IndiceArray indAr = (IndiceArray) pilhaSem.get(indice);
                    elemTab.setInfoC(new Array(deslocamento, indAr));
                    tabSimbolo.add(elemTab);
                    pilhaSem.remove(indice);
                    
                    /* Ajustar deslocamento */
                    deslocamento += indAr.getLimSuperior() - indAr.getLimInferior() + 1;
                }else{
                    elemTab.setInfoC(new Variavel(deslocamento++));
                    tabSimbolo.add(elemTab);
                    pilhaSem.remove(indice);
                }
            }
            
            mepa.append ("\tAMEM\t"+(deslocamento)+"\n");
            elemPilha = new VariaveisDeclaradas(deslocamento);
            pilhaSem.add(elemPilha);
        }
    }

    public void chamadaProcedimento(){
            
        /* Posicionar indice no início da chamada procedimento */
        int indice = pilhaSem.indexOf(Marca.CHAMADA_PROCEDIMENTO);
        pilhaSem.remove(indice);
        elemTab = (ElemTabSimb) pilhaSem.remove(indice);
        Procedimento proc = (Procedimento) elemTab.getInfoC();
        mepa.append ("\tCHPR\t"+"L"+proc.getRotulo()+"\n");
    }

    public void comandoLeitura(){

        /* Posicionar indice no início do comando de leitura */
        int indice = pilhaSem.indexOf(Marca.COMANDO_LEITURA);
        pilhaSem.remove(indice);
        ListIterator lisIt = pilhaSem.listIterator(indice);    

        while(lisIt.hasNext()){
            elemTab = (ElemTabSimb) lisIt.next();
            lisIt.remove();
            InfoComplementar infoC = elemTab.getInfoC();
            
            mepa.append ("\tLEIT\n");
            if( infoC instanceof Parametro){
                if(((Parametro)infoC).getMec() == Mecanismo.PAS_END){
                    mepa.append ("\tARMI\t"+ elemTab.getNivel()+","+((Parametro)infoC).getDeslocamento()+"\n");
                }else{
                    mepa.append ("\tARMZ\t"+ elemTab.getNivel()+","+((Parametro)infoC).getDeslocamento()+"\n");
                }
            }else if(infoC instanceof Variavel){
                if(infoC instanceof Array){
                    mepa.append ("\tARME\t"+elemTab.getNivel()+","+((Array)infoC).getDeslocamento()+"\n");
                }else{    
                    mepa.append ("\tARMZ\t"+elemTab.getNivel()+","+((Variavel)infoC).getDeslocamento()+"\n");
                }
            }
           
        }

    }

    public void armazena(){

        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        InfoComplementar infoC = elemTab.getInfoC();
        if( infoC instanceof Parametro){
            if(((Parametro)infoC).getMec() == Mecanismo.PAS_END){
                mepa.append ("\tARMI\t"+ elemTab.getNivel()+","+((Parametro)infoC).getDeslocamento()+"\n");
            }else{
                mepa.append ("\tARMZ\t"+ elemTab.getNivel()+","+((Parametro)infoC).getDeslocamento()+"\n");
            }
        }else if(infoC instanceof Variavel){
            if(infoC instanceof Array){
                if(comando_leitura == 1){
                    mepa.append ("\tARLA\t"+elemTab.getNivel()+","+((Array)infoC).getDeslocamento()+"\n");
                }else{
                    mepa.append ("\tARME\t"+elemTab.getNivel()+","+((Array)infoC).getDeslocamento()+"\n");
                }
            }else{    
                mepa.append ("\tARMZ\t"+elemTab.getNivel()+","+((Variavel)infoC).getDeslocamento()+"\n");
            }
        }else if(infoC instanceof Funcao){
            mepa.append ("\tARMZ\t"+(elemTab.getNivel()+1)+","+((Funcao)infoC).getDeslocamento()+"\n");
        }
    }

    /* Seta variáveis de controle para declaração de variáveis */
    public void iniciaDecVars(){
        contaVars = 0; 
        deslocamento = 0;
        pilhaSem.add(Marca.DECLARACAO_VARS);
    }

    public void liberaMemoria(){
        if(pilhaSem.peekLast() instanceof VariaveisDeclaradas){
            elemPilha = pilhaSem.pollLast();
            mepa.append("\tDMEM\t"+((VariaveisDeclaradas)elemPilha).getQuantidade()+"\n");
        }
        eliminaSimbolos(nivel);
        nivel--;
    }

    public void instanciaIdentificador(String id){
        elemTab = new ElemTabSimb(id, nivel);
        if(tabSimbolo.contains(elemTab)){
            report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            elemTab.setInfoC(new Variavel(contaVars));
            tabSimbolo.add(elemTab);
        }
    }

    /* Seta variáveis para a declaração de Procedimentos e Funções */
    public void iniciaDecProcFunc(){
        rotulo++;
        mepa.append ("\tDSVS\tL"+rotulo+"\n");
        pilhaSem.add(new Rotulo(rotulo));
    }

    /* Finaliza declaração de Procedimentos e Funções */
    public void finalizaDecProcFunc(){
        elemPilha = pilhaSem.pollLast();
        if(elemPilha instanceof Rotulo){
          mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
        }
    }

    public void inicioChamadaFuncao(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Função <"+id+"> não declarada!");
        }else{
            pilhaSem.add(elemTab);
            pre_rotina = 1;
            numeroArgumentos = 0;
            mepa.append ("\tAMEM\t"+1+"\n");
        }
    }

    /* Setar deslocamento para os parâmetros */
    public void deslocamentoParametros(){
        int i;
        Parametro p;
        LinkedList<Parametro> param = new LinkedList<Parametro>();

        /* Setar deslocamento para os parametros */
        for(i = numeroEntradas; i > 0; i--){            
            p = (Parametro) pilhaSem.pollLast();
            p.setDeslocamento(-3-(numeroEntradas-i));
            param.add(p);
        }

        /* Adicionar os parametros novamente */
        for( i = numeroEntradas; i > 0; i--){
            pilhaSem.add(param.pollLast());
        }
    }

    /* Seta o tipo de Mecanismo dos parâmentros */
    public void mecParametros(Mecanismo mec){
        /* auxNumParam - Controlar o numero de parametros */
        auxNumParam = numeroEntradas - auxNumParam;
        Parametro p;
        LinkedList <Parametro> param = new LinkedList<Parametro>();

        int i;
        /*            
        *  Retirar da pilha semântica e setar o tipo de macanismo e tipo do parametro
        *  Usar uma pilha auxiliar
        */
        for( i = auxNumParam; i > 0; i--){
            elemTab = (ElemTabSimb) pilhaSem.pollLast();               
            p = (Parametro) elemTab.getInfoC();
            p.setMec(mec);
            p.setTipo(Tipo.INTEGER);
            param.add(p);
        }

        /* Adicionar os parametros novamente */
        for( i = auxNumParam; i > 0; i--){
            pilhaSem.add(param.pollLast());
        }

        auxNumParam = numeroEntradas;
    }

    public void instanciaParametros(String id){
        elemTab = new ElemTabSimb(id, nivel);
        if(tabSimbolo.contains(elemTab)){
            report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            numeroEntradas++;
            elemTab.setInfoC(new Parametro());
            tabSimbolo.add(elemTab);
            pilhaSem.add(elemTab);
        }
    }
    
    public void inicioChamadaProc(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Procedimento <"+id+"> não declarado!");
        }else{
            pilhaSem.add(Marca.CHAMADA_PROCEDIMENTO);
            pilhaSem.add(elemTab);
        }
    }

    public void empilhaIdentificador(String id){
        elemTab = buscaSimbolo(id);
        if(elemTab == null){
            report_semantic_error ("Identificador <"+id+"> não declarado!");
        }else{
            pilhaSem.add(elemTab);
        }
    }

    public void inicioIF(){
        rotulo++;
        mepa.append ("\tDSVF\tL"+rotulo+"\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void fimIF(){
        elemPilha = pilhaSem.pollLast();
        mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
    }

    public void inicioElse(){
        rotulo++;
        mepa.append ("\tDSVS\tL"+rotulo+"\n");
        elemPilha = pilhaSem.pollLast();
        mepa.append ("L"+((Rotulo)elemPilha).getRotulo()+":\tNADA\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void inicioComRepetitivo(){
        rotulo++;
        mepa.append ("L"+rotulo+":\tNADA\n");
        pilhaSem.add (new Rotulo(rotulo));
    }

    public void condicaoWhile(){
        rotulo++;
        mepa.append ("\tDSVF\tL"+rotulo+"\n");
        pilhaSem.add (new Rotulo(rotulo));
    }
    
    public void fimWhile(){
        ultimoRotulo = (Rotulo) pilhaSem.pollLast();
        elemPilha = pilhaSem.pollLast();
        mepa.append ("\tDSVS\tL"+((Rotulo)elemPilha).getRotulo()+"\n");
        mepa.append ("L"+ultimoRotulo.getRotulo()+":\tNADA\n");
    }

    public void condicaoRepeat(){
        ultimoRotulo = (Rotulo) pilhaSem.pollLast();
        mepa.append ("\tDSVF\tL"+ultimoRotulo.getRotulo()+"\n");
    }

    public void varAcesso(){
        elemTab = (ElemTabSimb) pilhaSem.pollLast();
        InfoComplementar infoC = elemTab.getInfoC();
        if( infoC instanceof Array){
            mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            mepa.append ("\tSUBT\n");
            mepa.append ("\tCREL\t"+elemTab.getNivel()+","+((Array)infoC).getDeslocamento()+"\n");
        }else{
            mepa.append ("\tCRVL\t"+elemTab.getNivel()+","+((Variavel)infoC).getDeslocamento()+"\n");
        }
    }
:};

terminal 
        S_DIFERENTE, S_DOISPTOS, S_FECHAPAR, S_PROCEDURE, S_FUNCTION,
        S_MAIGUAL, S_MEIGUAL, S_PROGRAM, S_PONTOVG, S_ABREPAR, S_VIRGULA,
        S_ATRIBUI, S_NUMERO, S_WHILE, S_WRITE, S_READ, S_MAIOR, S_MENOR,
        S_IGUAL, S_MENOS, S_VEZES, S_PONTO, S_BEGIN, S_THEN,
        S_ELSE, S_MAIS, S_VAR, S_END, S_DIV, S_AND, S_NOT,
        S_IF, S_DO, S_OR, S_REPEAT, S_UNTIL, S_IDENTIF, S_CONST, S_TYPE,
        S_ARRAY, S_ABRECOL, S_FECHACOL, S_OF, S_PTOPTO
;

non terminal 
        programa, bloco, variaveis, declaracao_de_constante, declaracoes_de_vars,
        lista_de_identificadores, corpo, sequencia_comandos, denotacao_de_tipo,
        comando_sem_rotulo, chamada_comando_escrita, lista_de_constante, novo_tipo,
        chamada_comando_leitura, lista_de_expressoes, declaracao_de_tipo, novo_tipo_estrutura,
        lista_de_variaveis, atribuicao, composto, definicao_de_constante, estrutura_tipo,
        lista_comandos_sem_rotulo, condicional, alternativa_cond, lista_de_tipo, tipo_array,
        repetitivo, expressao, expressao_simples, termo, fator, tipo_de_retorno, tipo,
        declaracao_de_funcoes_e_procendimentos, lista_de_declaracao_de_funcao_ou_procedimento,
        declaracao_de_funcao_ou_procedimento, declaracao_de_procedimento, declaracao_de_funcao,
        cabecalho_procedimento, cabecalho_funcao, lista_formal_de_parametros, secao_lista_de_parametros_formais,
        secao_de_parametros_formais, parametro_por_valor, parametro_por_referencia, lista_de_parametros,
        chamada_procedimento, chamada_funcao, parametros, lista_de_parametros_atuais, parametros_atuais,
        lista_de_indices, definicao_de_tipo, tipo_indice, variavel_de_acesso, variavel_indexada,
        indice_de_lista_de_expressao
;

start with programa;

/*+----------------------------------------------------------+
  |        Producoes Sintaticas da linguagem PASCAL          |
  +----------------------------------------------------------+*/

programa 
    ::=
    {: 
        parser.mepa.append ("\tINPP\n"); 
    :}
    S_PROGRAM S_IDENTIF S_PONTOVG bloco S_PONTO
    {: 
        parser.mepa.append ("\tPARA\n\tFIM\n");
    :}
;

bloco
    ::= 
    {: 
        parser.nivel++; 
    :}
    declaracao_de_constante
    declaracao_de_tipo
    variaveis declaracao_de_funcoes_e_procendimentos
    corpo
    {:  
        parser.liberaMemoria();
    :}
;

variaveis
    ::=  /* vazio */
    | S_VAR 
    {: 
        parser.iniciaDecVars();
    :}
    declaracoes_de_vars
    {:
        parser.declaracaoVariaveis();
    :}
;

declaracao_de_constante
    ::=  /* vazio */
    | S_CONST lista_de_constante
;

lista_de_constante
    ::= lista_de_constante definicao_de_constante
    | definicao_de_constante
;

definicao_de_constante
    ::= S_IDENTIF:id
    {:
        parser.instanciaIdentificador(id.toString());
    :}
     S_IGUAL expressao S_PONTOVG
;

declaracao_de_tipo
    ::= /* vazio */
    | S_TYPE lista_de_tipo
;

lista_de_tipo
    ::= lista_de_tipo definicao_de_tipo
    | definicao_de_tipo
;

definicao_de_tipo
    ::= S_IDENTIF S_IGUAL denotacao_de_tipo S_PONTOVG
;

denotacao_de_tipo
    ::= 
    S_IDENTIF
    | novo_tipo
;

novo_tipo
    ::= novo_tipo_estrutura
;

novo_tipo_estrutura
    ::= estrutura_tipo
;

estrutura_tipo
    ::= tipo_array
;

tipo_array
    ::= S_ARRAY S_ABRECOL lista_de_indices S_FECHACOL S_OF tipo
;

tipo
    ::= denotacao_de_tipo
;

lista_de_indices
    ::= lista_de_indices S_VIRGULA tipo_indice
    | tipo_indice
;

tipo_indice
    ::= S_NUMERO: limInf S_PTOPTO S_NUMERO: limSup
    {:
        parser.verificaLimiteArray(limInf.toString(), limSup.toString());
    :}
;


declaracoes_de_vars
    ::= declaracoes_de_vars lista_de_identificadores S_DOISPTOS denotacao_de_tipo S_PONTOVG
    | lista_de_identificadores S_DOISPTOS denotacao_de_tipo S_PONTOVG
;

declaracao_de_funcoes_e_procendimentos
    ::=  /*vazio*/
    | {:
        parser.iniciaDecProcFunc();
      :}
    lista_de_declaracao_de_funcao_ou_procedimento S_PONTOVG
    {:
        parser.finalizaDecProcFunc();
    :}
;

lista_de_declaracao_de_funcao_ou_procedimento
    ::= lista_de_declaracao_de_funcao_ou_procedimento S_PONTOVG
    declaracao_de_funcao_ou_procedimento
    | declaracao_de_funcao_ou_procedimento
   
;

declaracao_de_funcao_ou_procedimento
    ::= {:
            parser.rotulo++;
            parser.auxNumParam = 0;
        :}
    declaracao_de_procedimento
    |   {:
            parser.rotulo++;
            parser.auxNumParam = 0;
        :}
    declaracao_de_funcao
;

declaracao_de_procedimento
    ::= 
    {: 
        parser.mepa.append ("L"+parser.rotulo+":\tENPR\t"+(parser.nivel+1)+"\n"); 
    :}
    cabecalho_procedimento
    {:
        parser.cabecalhoProcedimento();
    :}
    S_PONTOVG bloco
    {:
        parser.mepa.append ("\tRTPR\t"+(parser.nivel+1)+", "+parser.numeroEntradas+"\n");
    :}
;

cabecalho_procedimento
    ::= S_PROCEDURE S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    | S_PROCEDURE S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    lista_formal_de_parametros

;

declaracao_de_funcao
    ::= 
    {: 
        parser.mepa.append ("L"+parser.rotulo+":\tENPR\t"+(parser.nivel+1)+"\n"); 
    :}
    cabecalho_funcao
    {:
        parser.cabecalhoFuncao();
    :}
    S_PONTOVG bloco
    {:
        parser.mepa.append ("\tRTPR\t"+(parser.nivel+1)+", "+parser.numeroEntradas+"\n");
    :}
;

cabecalho_funcao
    ::= S_FUNCTION S_IDENTIF:id 
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    S_DOISPTOS tipo_de_retorno

    | S_FUNCTION S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        if(parser.tabSimbolo.contains(parser.elemTab)){
            parser.report_semantic_error ("Identificador <"+id+"> já declarado!");
        }else{
            parser.tabSimbolo.add(parser.elemTab);
            parser.pilhaSem.add(parser.elemTab);
        }
    :}
    lista_formal_de_parametros S_DOISPTOS tipo_de_retorno
;

tipo_de_retorno
    ::= S_IDENTIF:id
    {:
        //Buscar tipo na tabela de simbolos
        parser.pilhaSem.add(Tipo.INTEGER);
    :}
;

chamada_funcao
    ::= S_IDENTIF:id
    {:
        parser.inicioChamadaFuncao(id.toString());
    :}
    parametros 
;

lista_formal_de_parametros
    ::= S_ABREPAR 
    {:
        parser.nivel++;
        parser.numeroEntradas = 0;
    :}
    secao_lista_de_parametros_formais 
    {:
        parser.nivel--;
    :}
    S_FECHAPAR
    {:
        parser.deslocamentoParametros();
    :}
;

secao_lista_de_parametros_formais
    ::= secao_lista_de_parametros_formais S_PONTOVG secao_de_parametros_formais
    | secao_de_parametros_formais
;

secao_de_parametros_formais
    ::= parametro_por_valor
    | parametro_por_referencia
;

parametro_por_valor
    ::= lista_de_parametros S_DOISPTOS S_IDENTIF
    {:
        parser.mecParametros(Mecanismo.PAS_VAL);   
    :}
;

parametro_por_referencia
    ::= S_VAR lista_de_parametros S_DOISPTOS S_IDENTIF
    {:
        parser.mecParametros(Mecanismo.PAS_END);
    :}
;

lista_de_parametros
    ::= lista_de_parametros S_VIRGULA S_IDENTIF:id
    {:
        parser.instanciaParametros(id.toString());
    :}
    | S_IDENTIF:id
    {:
        parser.instanciaParametros(id.toString());
    :}
;

lista_de_identificadores
    ::= lista_de_identificadores S_VIRGULA S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);    
        parser.pilhaSem.add(parser.elemTab);
        parser.contaVars++;
    :}
    | S_IDENTIF:id
    {:
        parser.elemTab = new ElemTabSimb(id.toString(), parser.nivel);
        parser.pilhaSem.add(parser.elemTab);
        parser.contaVars++;
    :}
;

corpo
    ::= S_BEGIN sequencia_comandos S_END
;

sequencia_comandos
    ::= sequencia_comandos S_PONTOVG comando_sem_rotulo
    | comando_sem_rotulo
;
comando_sem_rotulo
    ::=  /* vazio */
    | chamada_comando_escrita
    |   {: parser.comando_leitura = 1; :}
        chamada_comando_leitura
        {: parser.comando_leitura = 0; :}
    | chamada_procedimento
        {:
            parser.chamadaProcedimento();
        :}
    | atribuicao
        {:
            parser.armazena();
        :}
    | composto
    | condicional
    | repetitivo
;

chamada_procedimento
    ::= S_IDENTIF:id
    {:
        parser.inicioChamadaProc(id.toString());
    :}
    parametros
    | S_IDENTIF:id
    {:
        parser.inicioChamadaProc(id.toString());
    :}
;

parametros
    ::= S_ABREPAR lista_de_parametros_atuais S_FECHAPAR
;

lista_de_parametros_atuais
    ::= lista_de_parametros_atuais S_VIRGULA parametros_atuais
    | parametros_atuais
;

parametros_atuais
    ::= expressao
    | expressao S_DOISPTOS expressao
    | expressao S_DOISPTOS expressao S_DOISPTOS expressao
;

chamada_comando_escrita
    ::= S_WRITE
    {:
        parser.comando_escrita = 1;
    :}
    S_ABREPAR lista_de_expressoes S_FECHAPAR
    {:
        parser.comando_escrita = 0;
    :}
;

chamada_comando_leitura
    ::= S_READ
    {:
        //parser.pilhaSem.add(Marca.COMANDO_LEITURA);
    :}
    S_ABREPAR lista_de_variaveis S_FECHAPAR
;

lista_de_expressoes
    ::=  /* vazio */
    | lista_de_expressoes S_VIRGULA 
    expressao
    {:
        if(parser.comando_escrita == 1){
            parser.mepa.append ("\tIMPR\n");
        }
    :}
    | expressao
    {:
        if(parser.comando_escrita == 1){
            parser.mepa.append ("\tIMPR\n");
        }
    :}
;

lista_de_variaveis
    ::=  /* vazio */
    | lista_de_variaveis S_VIRGULA {: parser.mepa.append("\tLEIT\n"); :}
    variavel_de_acesso
    {:
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.peekLast();
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if( infoC instanceof Array){
            parser.mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            parser.mepa.append ("\tSUBT\n");
        }
        parser.armazena();
    :}
    | {: parser.mepa.append("\tLEIT\n"); :} variavel_de_acesso
    {:
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.peekLast();
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if( infoC instanceof Array){
            parser.mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            parser.mepa.append ("\tSUBT\n");
        }
        parser.armazena();
    :}

;

atribuicao
    ::= variavel_de_acesso
    {:
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.peekLast();
        InfoComplementar infoC = parser.elemTab.getInfoC();
        if( infoC instanceof Array){
            parser.mepa.append ("\tCRCT\t"+((Array)infoC).getLimInferior()+"\n");
            parser.mepa.append ("\tSUBT\n");
        }
    :}
    S_ATRIBUI expressao
;

variavel_de_acesso
    ::= 
    S_IDENTIF:id
    {:
        parser.empilhaIdentificador(id.toString());
    :}
    | variavel_indexada
;

variavel_indexada
    ::= variavel_de_acesso S_ABRECOL indice_de_lista_de_expressao S_FECHACOL
;

indice_de_lista_de_expressao
    ::= indice_de_lista_de_expressao S_VIRGULA expressao
    | expressao
;

composto
    ::= S_BEGIN lista_comandos_sem_rotulo S_END
;

lista_comandos_sem_rotulo
    ::= lista_comandos_sem_rotulo S_PONTOVG comando_sem_rotulo
    | comando_sem_rotulo
;

condicional
    ::= S_IF
    expressao
    {:
        parser.inicioIF();
    :}
    S_THEN
    comando_sem_rotulo
    alternativa_cond
    {:
        parser.fimIF();
    :}
;

alternativa_cond
    ::= /* vazio */
    | S_ELSE
    {:
        parser.inicioElse();
    :}
    comando_sem_rotulo
;

repetitivo
    ::= S_WHILE
    {:
        parser.inicioComRepetitivo();
    :}
    expressao
    {:
        parser.condicaoWhile();
    :}
    S_DO comando_sem_rotulo
    {:
        parser.fimWhile();
    :}
    |
    S_REPEAT
    {:
        parser.inicioComRepetitivo();
    :}
    sequencia_comandos
    S_UNTIL
    expressao
    {:
        parser.condicaoRepeat();
    :}
;

expressao
    ::= expressao_simples S_IGUAL expressao_simples
    {: 
        parser.mepa.append ("\tCMIG\n"); 
    :}
    | expressao_simples S_DIFERENTE expressao_simples
    {:  
        parser.mepa.append ("\tCMDG\n"); 
    :}
    | expressao_simples S_MENOR expressao_simples
    {: 
        parser.mepa.append ("\tCMME\n"); 
    :}
    | expressao_simples S_MAIOR expressao_simples
    {: 
        parser.mepa.append ("\tCMMA\n"); 
    :}
    | expressao_simples S_MEIGUAL expressao_simples
    {: 
        parser.mepa.append ("\tCMEG\n"); 
    :}
    | expressao_simples S_MAIGUAL expressao_simples
    {: 
        parser.mepa.append ("\tCMAG\n"); 
    :}
    | expressao_simples
;

expressao_simples
    ::= expressao_simples S_MAIS  termo
    {: 
        parser.mepa.append ("\tSOMA\n"); 
    :}
    | expressao_simples S_MENOS termo
    {: 
        parser.mepa.append ("\tSUBT\n"); 
    :}
    | expressao_simples S_OR termo
    {: 
        parser.mepa.append ("\tDISJ\n"); 
    :}
    | S_MAIS termo
    | S_MENOS termo
    {: 
        parser.mepa.append ("\tINVR\n"); 
    :}
    | termo
;

termo
    ::= termo S_VEZES fator
    {: 
        parser.mepa.append ("\tMULT\n"); 
    :}
    | termo S_DIV fator
    {: 
        parser.mepa.append ("\tDIVI\n"); 
    :}
    | termo S_AND fator
    {: 
        parser.mepa.append ("\tCONJ\n"); 
    :}
    | fator
;

fator
    ::=
    variavel_de_acesso
    {:
        parser.varAcesso();
    :}
    | S_NUMERO:numero
    {: 
        parser.mepa.append ("\tCRCT\t"+numero+"\n"); 
    :}
    | chamada_funcao
    {:
        parser.pre_rotina = 0;
        parser.numeroArgumentos = 0;
        parser.elemTab = (ElemTabSimb) parser.pilhaSem.pollLast();
        Funcao func = (Funcao) parser.elemTab.getInfoC();
        parser.mepa.append ("\tCHPR\t"+"L"+func.getRotulo()+"\n");
     :}
    | S_ABREPAR expressao S_FECHAPAR
    | S_NOT fator
    {: 
        parser.mepa.append ("\tNEGA\n"); 
    :}
;